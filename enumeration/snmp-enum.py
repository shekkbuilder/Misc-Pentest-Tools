#!/usr/bin/env python
#
# Script name     : snmp-enum.py
# Version         : 2.0
# Created date    : 3/1/2017
# Last update     : 7/18/2017
# Needed Modules  : pysnmp
# Inspired by     : snmp-check
# Author          : wetw0rk
# Python version  : 2.7
# Description     : When conducting a pen-test it can be hard to read or decipher
#                   the output when you walk the entire MIB tree; this script allows
#                   you to easily read the output. I prevously used snmpwalk in a loop
#                   however this script allows me to re-use the code on a linux box that
#                   does not necessarily have snmpwalk installed. Keep note this is a
#		    quick and dirty script.
#

import os, sys, time, argparse
from pysnmp.entity.rfc3413.oneliner import cmdgen

# we are going to want to make the output neat and readable so put output in list
addr_list = []; port_list = []; ladd = []; lprt = []; radd = []; rprt = [];
cond = []; name_list = []; path_list = []; id_list = []; status = []; param_list = [];

# The following are the OIDS we want to enumerate :)
sys_info = {
	'Hostname\t\t': '1.3.6.1.2.1.1.5.0', 'Description\t\t': '1.3.6.1.2.1.1.1.0',
	'Contact\t\t\t': '1.3.6.1.2.1.1.4.0', 'Location\t\t': '1.3.6.1.2.1.1.6.0',
	'Uptime snmp\t\t': '1.3.6.1.2.1.25.1.1.0', 'Uptime system\t\t': '1.3.6.1.2.1.1.3.0',
}

net_info = {
	'IP forwarding enabled\t': '1.3.6.1.2.1.4.1.0', 'Default TTL\t\t': '1.3.6.1.2.1.4.2.0',
	'TCP segments received\t':'1.3.6.1.2.1.6.10.0', 'TCP segments sent\t': '1.3.6.1.2.1.6.11.0',
	'TCP segments retrans\t': '1.3.6.1.2.1.6.12.0', 'Input datagrams\t\t': '1.3.6.1.2.1.4.3.0',
	'Delivered datagrams\t': '1.3.6.1.2.1.4.9.0', 'Output datagrams\t': '1.3.6.1.2.1.4.10.0'
}

udp_port = {'uaddress': '1.3.6.1.2.1.7.5.1.1', 'uport': '1.3.6.1.2.1.7.5.1.2'}

usernames = {'Username found\t\t': '1.3.6.1.4.1.77.1.2.25'}

tcp_port = {'taddress': '1.3.6.1.2.1.6.13.1.2', 'tport': '1.3.6.1.2.1.6.13.1.3',
	'raddress': '1.3.6.1.2.1.6.13.1.4', 'rport': '1.3.6.1.2.1.6.13.1.5',
	'state': '1.3.6.1.2.1.6.13.1.1'
}

processes = { 'id': '1.3.6.1.2.1.25.4.2.1.1', 'status': '1.3.6.1.2.1.25.4.2.1.7',
	'Name': '1.3.6.1.2.1.25.4.2.1.2', 'Path': '1.3.6.1.2.1.25.4.2.1.4',
	'Param': '1.3.6.1.2.1.25.4.2.1.5'
}

addr_list = []; port_list = []; ladd = []; lprt = []; radd = []; rprt = [];
cond = []; name_list = []; path_list = []; id_list = []; status = [];
param_list = [];


# simple lookup list for TCP states
lookup = [ 'closed', 'listen', 'synSent', 'synReceived',
	'established', 'finWait1', 'finWait2', 'closeWait',
	'lastAck', 'closing', 'timeWait', 'deleteTCB'
	]

# easier to distinguish output
class bcolors:
        OKGREEN = '\033[92m'
        ENDC = '\033[0m'

def snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, oid):

	cmdGen = cmdgen.CommandGenerator()

	errorIndication, errorStatus, errorIndex, varBinds = cmdGen.getCmd(
		cmdgen.CommunityData(SNMP_COMMUNITY),
		cmdgen.UdpTransportTarget((SNMP_HOST, SNMP_PORT)),
	oid)

	# engine errors
	if errorIndication:
		print(errorIndication)
	else:
		# agent errors
		if errorStatus:
			print('%s at %s' % (
				errorStatus.prettyPrint(),
				errorIndex and varBinds[int(errorIndex)-1] or '?'
			)
		)
		else:
			# snmp response contents
			for name, val in varBinds:
				# check for IP forwarding
				if key == 'IP forwarding enabled\t':
					if val.prettyPrint() != 1:
						print('%s: %s' % (key, "no"))
					else:
						print('%s: %s' % (key, "yes"))
				else:
					print('%s: %s' % (key, val.prettyPrint()))

def snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, oid):

	global name_list, path_list, port_list, addr_list
	global ladd, lprt, radd, rprt, cond, status, id_list
	global param_list


	cmdGen = cmdgen.CommandGenerator()

	errorIndication, errorStatus, errorIndex, varBindTable = cmdGen.nextCmd(
		cmdgen.CommunityData(SNMP_COMMUNITY),
		cmdgen.UdpTransportTarget((SNMP_HOST, SNMP_PORT)),
		oid
	)
	# engine errors
	if errorStatus:
		print('%s at %s' % (
			errorStatus.prettyPrint(),
			errorIndex and varBindTable[-1][int(errorIndex)-1] or '?'
			)
		)
	else:
		for varBindTableRow in varBindTable:
			# snmp response contents
			for name, val in varBindTableRow:
				# for any process
				if key == 'Name':
					name_list += val.prettyPrint().split("\n")
				elif key == 'Path':
					path_list += val.prettyPrint().split("\n")
				elif key == 'id':
					id_list += val.prettyPrint().split("\n")
				elif key == 'status':
					if val.prettyPrint() == str(1):
						status += 'running',
					elif val.prettyPrint() == str(2):
						status += 'runnable',
					else:
						status += 'unknown',
				elif key == 'Param':
					param_list += val.prettyPrint().split("\n")
				# udp detection
				elif key == 'uaddress':
					addr_list += val.prettyPrint().split("\n")
				elif key == 'uport':
					port_list += val.prettyPrint().split("\n")
				# tcp detection
				elif key == 'taddress':
					ladd += val.prettyPrint().split("\n")
				elif key == 'tport':
					lprt += val.prettyPrint().split("\n")
				elif key == 'raddress':
					radd += val.prettyPrint().split("\n")
				elif key == 'rport':
					rprt += val.prettyPrint().split("\n")
				elif key == 'state':
					cond += val.prettyPrint()
				else:
					print('%s: %s' % (key, val.prettyPrint()))


def snmpcheck(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY):

	global key

	# get the system info
	print bcolors.OKGREEN + "[*] System information:\n" + bcolors.ENDC
	print "Host IP\t\t\t: %s" % SNMP_HOST
	for key in sys_info:
	        answer = snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, sys_info[key])
	# networking information
	print bcolors.OKGREEN + "\n[*] Network information:\n" + bcolors.ENDC
	for key in net_info:
	        answer = snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, net_info[key])
	# listening udp ports
	print bcolors.OKGREEN + "\n[*] Listening UDP ports:\n" + bcolors.ENDC
	for key in udp_port:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, udp_port[key])
	# neatly print ports
	for i in range(len(addr_list)):
		print (addr_list[i] + '\t' + port_list[i]).expandtabs(30)
	# listening tcp ports
	print bcolors.OKGREEN + "\n[*] Listening TCP ports:\n" + bcolors.ENDC
	for key in tcp_port:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, tcp_port[key])
	# neatly print
	print("Local address" + '\t' + "Local port" + '\t' + "Remote address" + '\t' + "Remote port" + '\t' + 'State\n').expandtabs(30)
	for i in range(len(lprt)):
		print(ladd[i] + '\t' + lprt[i] + '\t' + radd[i] + '\t' + rprt[i] + '\t' + lookup[int(cond[i]) - 1]).expandtabs(30)
	# running processes
	print bcolors.OKGREEN + "\n[*] Running Processes:\n" + bcolors.ENDC
	for key in processes:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, processes[key])
	print("Id" + "\t" + "Status" + "\t" + "Name" + "\t" + "Path" + "\t" + "Parameters\n").expandtabs(30)
	for i in range(len(path_list)):
		# neatly print the output
	        print(id_list[i] + "\t" + status[i] + "\t" + name_list[i] + "\t" + path_list[i] + "\t" + param_list[i]).expandtabs(30)
	# username enumeration
	print bcolors.OKGREEN + "\n[*] Usernames:\n" + bcolors.ENDC
	for key in usernames:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, usernames[key])



def main():

	# handle arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-t", "--target", help="target to enumerate")
	parser.add_argument("-p", "--port", help="target port")
	parser.add_argument("-c", "--community", help="public community string")
	args = parser.parse_args()
	# assign args
	SNMP_HOST = args.target
	SNMP_PORT = args.port
	SNMP_COMMUNITY = args.community
	# print msg if error
	if SNMP_HOST > 1:
		snmpcheck(SNMP_HOST, int(SNMP_PORT), SNMP_COMMUNITY)
	else:
		print(parser.print_help())

main()
