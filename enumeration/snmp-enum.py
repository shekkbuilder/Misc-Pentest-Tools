#!/usr/bin/env python
#
# Script name     : snmp-enum.py
# Version         : 2.0
# Created date    : 3/1/2017
# Last update     : 7/18/2017
# Needed Modules  : pysnmp
# Inspired by     : snmp-check
# Author          : wetw0rk
# Python version  : 2.7
# Description     : When conducting a pen-test it can be hard to read or decipher
#                   the output when you walk the entire MIB tree; this script allows
#                   you to easily read the output. I prevously used snmpwalk in a loop
#                   however this script allows me to re-use the code on a linux box that
#                   does not necessarily have snmpwalk installed.
#

import os, sys, time, argparse
from pysnmp.entity.rfc3413.oneliner import cmdgen

class bcolors:
	OKGREEN = '\033[92m'
	ENDC = '\033[0m'

sys_info = {
        'Hostname\t\t':         '1.3.6.1.2.1.1.5.0',
        'Description\t\t':      '1.3.6.1.2.1.1.1.0',
        'Contact\t\t\t':        '1.3.6.1.2.1.1.4.0',
        'Location\t\t':         '1.3.6.1.2.1.1.6.0',
        'Uptime snmp\t\t':      '1.3.6.1.2.1.25.1.1.0',
        'Uptime system\t\t':    '1.3.6.1.2.1.1.3.0',
        }

net_info = {
        'IP forwarding enabled\t':      '1.3.6.1.2.1.4.1.0',
        'Default TTL\t\t':              '1.3.6.1.2.1.4.2.0',
        'TCP segments received\t':      '1.3.6.1.2.1.6.10.0',
        'TCP segments sent\t':          '1.3.6.1.2.1.6.11.0',
        'TCP segments retrans\t':       '1.3.6.1.2.1.6.12.0',
        'Input datagrams\t\t':          '1.3.6.1.2.1.4.3.0',
        'Delivered datagrams\t':        '1.3.6.1.2.1.4.9.0',
        'Output datagrams\t':           '1.3.6.1.2.1.4.10.0'
        }

udp_port = {'Listening\t\t': '1.3.6.1.2.1.7.5.1.2'}
tcp_port = {'Listening\t\t': '1.3.6.1.2.1.6.13.1.3'}

processes = {
        'Name': '1.3.6.1.2.1.25.4.2.1.2',
        'Path': '1.3.6.1.2.1.25.4.2.1.4'
        }

usernames = {'Username found\t\t': '1.3.6.1.4.1.77.1.2.25'}

class bcolors:
        OKGREEN = '\033[92m'
        ENDC = '\033[0m'


# holds some output
name_list = []
parm_list = []

def snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, oid):

	cmdGen = cmdgen.CommandGenerator()

	errorIndication, errorStatus, errorIndex, varBinds = cmdGen.getCmd(
		cmdgen.CommunityData(SNMP_COMMUNITY),
		cmdgen.UdpTransportTarget((SNMP_HOST, SNMP_PORT)),
	oid)

	# engine errors
	if errorIndication:
		print(errorIndication)
	else:
		# agent errors
		if errorStatus:
			print('%s at %s' % (
				errorStatus.prettyPrint(),
				errorIndex and varBinds[int(errorIndex)-1] or '?'
			)
		)
		else:
			# snmp response contents
			for name, val in varBinds:
				if key == 'IP forwarding enabled\t':
					if val.prettyPrint() != 1:
						print('%s: %s' % (key, "no"))
					else:
						print('%s: %s' % (key, "yes"))
				else:
					print('%s: %s' % (key, val.prettyPrint()))

def snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, oid):

	global name_list
	global parm_list

	cmdGen = cmdgen.CommandGenerator()

	errorIndication, errorStatus, errorIndex, varBindTable = cmdGen.nextCmd(
		cmdgen.CommunityData(SNMP_COMMUNITY),
		cmdgen.UdpTransportTarget((SNMP_HOST, SNMP_PORT)),
		oid
	)
	# engine errors
	if errorStatus:
		print('%s at %s' % (
			errorStatus.prettyPrint(),
			errorIndex and varBindTable[-1][int(errorIndex)-1] or '?'
			)
		)
	else:
		for varBindTableRow in varBindTable:
			# snmp response contents
			for name, val in varBindTableRow:
				if key == 'Name':
					name_list += val.prettyPrint().split("\n")
				elif key == 'Path':
					parm_list += val.prettyPrint().split("\n")
				else:
					print('%s: %s' % (key, val.prettyPrint()))


def snmpcheck(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY):

	global key

	# get the system info
	print bcolors.OKGREEN + "[*] System information:\n" + bcolors.ENDC
	print "Host IP\t\t\t: %s" % SNMP_HOST
	for key in sys_info:
	        answer = snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, sys_info[key])
	# networking information
	print bcolors.OKGREEN + "\n[*] Network information:\n" + bcolors.ENDC
	for key in net_info:
	        answer = snmpget(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, net_info[key])
	# listening udp ports
	print bcolors.OKGREEN + "\n[*] Listening UDP ports:\n" + bcolors.ENDC
	for key in udp_port:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, udp_port[key])
	# listening tcp ports
	print bcolors.OKGREEN + "\n[*] Listening TCP ports:\n" + bcolors.ENDC
	for key in tcp_port:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, tcp_port[key])
	# running processes
	print bcolors.OKGREEN + "\n[*] Running Processes:\n" + bcolors.ENDC
	for key in processes:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, processes[key])
	print ("Name" + "\t" + "Path\n").expandtabs(30)
	for i in range(len(parm_list)):
		# neatly print the output
	        print (name_list[i] + '\t' + parm_list[i]).expandtabs(30)
	# username enumeration
	print bcolors.OKGREEN + "\n[*] Usernames\n" + bcolors.ENDC
	for key in usernames:
	        answer = snmpwalk(SNMP_HOST, SNMP_PORT, SNMP_COMMUNITY, usernames[key])



def main():

	# handle arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-t", "--target", help="target to enumerate")
	parser.add_argument("-p", "--port", help="target port")
	parser.add_argument("-c", "--community", help="public community string")
	args = parser.parse_args()
	# assign args
	SNMP_HOST = args.target
	SNMP_PORT = args.port
	SNMP_COMMUNITY = args.community
	# print msg if error
	if SNMP_HOST > 1:
		snmpcheck(SNMP_HOST, int(SNMP_PORT), SNMP_COMMUNITY)
	else:
		print(parser.print_help())

main()
