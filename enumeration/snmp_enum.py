#!/usr/bin/env python

# Script name		:	snmp-enum.py
# Version			:	2.1
# Created date		:	3/1/2017
# Last update		:	7/18/2017
# Needed Modules	:	pysnmp
# Inspired by		:	snmp-check
# Author			:	wetw0rk
# Contributor       :   ruffm
# Python version    :   2.7
# Description       :   When conducting a pen-test it can be hard to read or decipher
#                       the output when you walk the entire MIB tree; this script allows
#                       you to easily read the output. I prevously used snmpwalk in a loop
#                       however this script allows me to re-use the code on a linux box that
#                       does not necessarily have snmpwalk installed. Keep note this is a
#                       quick and dirty script.

import argparse
from pysnmp.entity.rfc3413.oneliner import cmdgen

addr_list = []
port_list = []
ladd = []
lprt = []
radd = []
rprt = []
cond = []
name_list = []
path_list = []
id_list = []
status = []
param_list = []

sys_info = {  # The following are the OIDS we want to enumerate :)
    'Hostname\t\t': '1.3.6.1.2.1.1.5.0',
    'Description\t\t': '1.3.6.1.2.1.1.1.0',
    'Contact\t\t\t': '1.3.6.1.2.1.1.4.0',
    'Location\t\t': '1.3.6.1.2.1.1.6.0',
    'Uptime snmp\t\t': '1.3.6.1.2.1.25.1.1.0',
    'Uptime system\t\t': '1.3.6.1.2.1.1.3.0',
}

net_info = {
    'IP forwarding enabled\t': '1.3.6.1.2.1.4.1.0',
    'Default TTL\t\t': '1.3.6.1.2.1.4.2.0',
    'TCP segments received\t': '1.3.6.1.2.1.6.10.0',
    'TCP segments sent\t': '1.3.6.1.2.1.6.11.0',
    'TCP segments retrans\t': '1.3.6.1.2.1.6.12.0',
    'Input datagrams\t\t': '1.3.6.1.2.1.4.3.0',
    'Delivered datagrams\t': '1.3.6.1.2.1.4.9.0',
    'Output datagrams\t': '1.3.6.1.2.1.4.10.0'
}

udp_port = {
    'uaddress': '1.3.6.1.2.1.7.5.1.1',
    'uport': '1.3.6.1.2.1.7.5.1.2'
}

usernames = {
    'Username found\t\t': '1.3.6.1.4.1.77.1.2.25'
}

tcp_port = {
    'taddress': '1.3.6.1.2.1.6.13.1.2',
    'tport': '1.3.6.1.2.1.6.13.1.3',
    'raddress': '1.3.6.1.2.1.6.13.1.4',
    'rport': '1.3.6.1.2.1.6.13.1.5',
    'state': '1.3.6.1.2.1.6.13.1.1'
}

processes = {
    'id': '1.3.6.1.2.1.25.4.2.1.1',
    'status': '1.3.6.1.2.1.25.4.2.1.7',
    'Name': '1.3.6.1.2.1.25.4.2.1.2',
    'Path': '1.3.6.1.2.1.25.4.2.1.4',
    'Param': '1.3.6.1.2.1.25.4.2.1.5'
}

lookup = ['closed',
          'listen',
          'synSent',
          'synReceived',
          'established',
          'finWait1',
          'finWait2',
          'closeWait',
          'lastAck',
          'closing',
          'timeWait',
          'deleteTCB'
          ]

class BColors:  # easier to distinguish output
    def __init__(self):
        pass

    ok_green = '\033[92m'
    end_c = '\033[0m'

def snmpget(snmp_host, snmp_port, snmp_community, oid):
    cmd_gen = cmdgen.CommandGenerator()

    error_indication, error_status, error_index, var_binds = cmd_gen.getCmd(
        cmdgen.CommunityData(snmp_community),
        cmdgen.UdpTransportTarget((snmp_host, snmp_port)),
        oid)

    if error_indication:  # engine errors
        print(error_indication)

    else:
        if error_status:  # agent errors
            print('%s at %s' % (
                error_status.prettyPrint(),
                error_index and var_binds[int(error_index) - 1] or '?')
                  )

        else:
            for name, val in var_binds:  # snmp response contents
                if key == 'IP forwarding enabled\t':  # check for IP forwarding
                    if val.prettyPrint() != 1:
                        print('%s: %s' % (key, "no"))

                    else:
                        print('%s: %s' % (key, "yes"))

                else:
                    print('%s: %s' % (key, val.prettyPrint()))


def snmpwalk(snmp_host, snmp_port, snmp_community, oid):
    global name_list, path_list, port_list, addr_list
    global ladd, lprt, radd, rprt, cond, status, id_list
    global param_list

    cmd_gen = cmdgen.CommandGenerator()

    error_indication, error_status, error_index, var_bind_table = cmd_gen.nextCmd(
        cmdgen.CommunityData(snmp_community),
        cmdgen.UdpTransportTarget((snmp_host, snmp_port)),
        oid
    )

    if error_status:  # engine errors
        print('%s at %s' % (
            error_status.prettyPrint(),
            error_index and var_bind_table[-1][int(error_index) - 1] or '?')
              )
    else:
        for varBindTableRow in var_bind_table:  # snmp response contents
            for name, val in varBindTableRow:  # for any process
                if key == 'Name':
                    name_list += val.prettyPrint().split("\n")

                elif key == 'Path':
                    path_list += val.prettyPrint().split("\n")

                elif key == 'id':
                    id_list += val.prettyPrint().split("\n")

                elif key == 'status':
                    if val.prettyPrint() == str(1):
                        status += 'running',

                    elif val.prettyPrint() == str(2):
                        status += 'runnable',

                    else:
                        status += 'unknown',

                elif key == 'Param':
                    param_list += val.prettyPrint().split("\n")

                elif key == 'uaddress':  # udp detection
                    addr_list += val.prettyPrint().split("\n")

                elif key == 'uport':
                    port_list += val.prettyPrint().split("\n")

                elif key == 'taddress':  # tcp detection
                    ladd += val.prettyPrint().split("\n")

                elif key == 'tport':
                    lprt += val.prettyPrint().split("\n")

                elif key == 'raddress':
                    radd += val.prettyPrint().split("\n")

                elif key == 'rport':
                    rprt += val.prettyPrint().split("\n")

                elif key == 'state':
                    cond += val.prettyPrint()

                else:
                    print('%s: %s' % (key, val.prettyPrint()))


def snmpcheck(snmp_host, snmp_port, snmp_community):
    global key # this doesn't need to be global??

    print BColors.ok_green + "[*] System information:\n" + BColors.end_c # get the system info
    print "Host IP\t\t\t: %s" % snmp_host

    for key in sys_info:
        snmpget(snmp_host, snmp_port, snmp_community, sys_info[key]) # networking information
    print BColors.ok_green + "\n[*] Network information:\n" + BColors.end_c

    for key in net_info:
        snmpget(snmp_host, snmp_port, snmp_community, net_info[key]) # listening udp ports
    print BColors.ok_green + "\n[*] Listening UDP ports:\n" + BColors.end_c

    for key in udp_port:
        snmpwalk(snmp_host, snmp_port, snmp_community, udp_port[key])

    for i in range(len(addr_list)): # neatly print ports
        print(addr_list[i] + '\t' + port_list[i]).expandtabs(30)

    print BColors.ok_green + "\n[*] Listening TCP ports:\n" + BColors.end_c # listening tcp ports

    for key in tcp_port:
	    snmpwalk(snmp_host, snmp_port, snmp_community, tcp_port[key])

    print(
        "Local address" + '\t' +
        "Local port" + '\t' +
        "Remote address" + '\t' +
        "Remote port" + '\t' +
        'State\n').expandtabs(30)

    for i in range(len(lprt)):
        print(ladd[i] + '\t' +
              lprt[i] + '\t' +
              radd[i] + '\t' +
              rprt[i] + '\t' +
              lookup[int(cond[i]) - 1]).expandtabs(30)

    print BColors.ok_green + "\n[*] Running Processes:\n" + BColors.end_c

    for key in processes:
        snmpwalk(snmp_host, snmp_port, snmp_community, processes[key])

    print("Id" + "\t" +
          "Status" + "\t" +
          "Name" + "\t" +
          "Path" + "\t" +
          "Parameters\n").expandtabs(30)

    for i in range(len(path_list)):
        print(id_list[i] + "\t" +
              status[i] + "\t" +
              name_list[i] + "\t" +
              path_list[i] + "\t" +
              param_list[i]).expandtabs(30)

    print BColors.ok_green + "\n[*] Usernames:\n" + BColors.end_c  # username enumeration
    for key in usernames:
        snmpwalk(snmp_host, snmp_port, snmp_community, usernames[key])

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", help="target to enumerate")
    parser.add_argument("-p", "--port", help="target port")
    parser.add_argument("-c", "--community", help="public community string")
    args = parser.parse_args()
    snmp_host = args.target
    snmp_port = args.port
    snmp_community = args.community

    if snmp_host > 1:
        snmpcheck(snmp_host, int(snmp_port), snmp_community)

    else:
        print(parser.print_help())

if __name__ == '__main__':
    main()
