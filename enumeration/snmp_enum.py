#!/usr/bin/env python
#
# Script name		: snmp-enum.py
# Version		: 2.1
# Created date		: 3/1/2017
# Last update		: 7/18/2017
# Needed Modules	: pysnmp
# Inspired by		: snmp-check
# Author		: wetw0rk
# Contributor       	: ruffm
# Python version    	: 2.7
# Description       	: When conducting a pen-test it can be hard to read or decipher
#                      	  the output when you walk the entire MIB tree; this script allows
#                         you to easily read the output. I prevously used snmpwalk in a loop
#                         however this script allows me to re-use the code on a linux box that
#                         does not necessarily have snmpwalk installed. Keep note this is a
#                         quick and dirty script.

import struct, argparse
from pysnmp.entity.rfc3413.oneliner import cmdgen

addr_list	= []
port_list	= []
ladd		= []
lprt		= []
radd		= []
rprt		= []
cond		= []
name_list	= []
path_list	= []
id_list		= []
status		= []
param_list	= []

ifindex		= []
ifdescr		= []
ifmac		= []
iftype		= []
ifmtu		= []
ifspeed		= []
ifinoc		= []
ifoutoc		= []
ifstatus	= []

ifidv		= []
ipaddrv		= []
netmaskv	= []
bcastv		= []

destv		= []
hopv		= []
maskv		= []
metricv		= []

system_information = {
	'Hostname\t\t'			: '1.3.6.1.2.1.1.5.0',
	'Description\t\t'		: '1.3.6.1.2.1.1.1.0',
	'Contact\t\t\t'			: '1.3.6.1.2.1.1.4.0',
	'Location\t\t'			: '1.3.6.1.2.1.1.6.0',
	'Uptime snmp\t\t'		: '1.3.6.1.2.1.25.1.1.0',
	'Uptime system\t\t'		: '1.3.6.1.2.1.1.3.0',
}

network_information = {
	'IP forwarding enabled\t'	: '1.3.6.1.2.1.4.1.0',
	'Default TTL\t\t'		: '1.3.6.1.2.1.4.2.0',
	'TCP segments received\t'	: '1.3.6.1.2.1.6.10.0',
	'TCP segments sent\t'		: '1.3.6.1.2.1.6.11.0',
	'TCP segments retrans\t'	: '1.3.6.1.2.1.6.12.0',
	'Input datagrams\t\t'		: '1.3.6.1.2.1.4.3.0',
	'Delivered datagrams\t'		: '1.3.6.1.2.1.4.9.0',
	'Output datagrams\t'		: '1.3.6.1.2.1.4.10.0'
}

network_interfaces = {
	'index'		: '1.3.6.1.2.1.2.2.1.1',
	'descr'		: '1.3.6.1.2.1.2.2.1.2',
	'mac'		: '1.3.6.1.2.1.2.2.1.6',
	'type'		: '1.3.6.1.2.1.2.2.1.3',
	'mtu'		: '1.3.6.1.2.1.2.2.1.4',
	'speed'		: '1.3.6.1.2.1.2.2.1.5',
	'inoc'		: '1.3.6.1.2.1.2.2.1.10',
	'outoc'		: '1.3.6.1.2.1.2.2.1.16',
	'cur_status'	: '1.3.6.1.2.1.2.2.1.7'
}

network_ip = {
	"ifid"		: '1.3.6.1.2.1.4.20.1.2',
	"ipaddr"	: '1.3.6.1.2.1.4.20.1.1',
	"netmask"	: '1.3.6.1.2.1.4.20.1.3',
	"bcast"		: '1.3.6.1.2.1.4.20.1.4'
}

routing_information = {
	"dest"		: "1.3.6.1.2.1.4.21.1.1",
	"hop"		: "1.3.6.1.2.1.4.21.1.7",
	"mask"		:"1.3.6.1.2.1.4.21.1.11",
	"metric"	:"1.3.6.1.2.1.4.21.1.3"
}

udp_port = {
	'uaddress'	: '1.3.6.1.2.1.7.5.1.1',
	'uport'		: '1.3.6.1.2.1.7.5.1.2'
}

usernames = {
	'Username found\t\t'	: '1.3.6.1.4.1.77.1.2.25'
}

tcp_port = {
	'taddress'	: '1.3.6.1.2.1.6.13.1.2',
	'tport'		: '1.3.6.1.2.1.6.13.1.3',
	'raddress'	: '1.3.6.1.2.1.6.13.1.4',
	'rport'		: '1.3.6.1.2.1.6.13.1.5',
	'state'		: '1.3.6.1.2.1.6.13.1.1'
}

processes = {
	'id'		: '1.3.6.1.2.1.25.4.2.1.1',
	'status'	: '1.3.6.1.2.1.25.4.2.1.7',
	'Name'		: '1.3.6.1.2.1.25.4.2.1.2',
	'Path'		: '1.3.6.1.2.1.25.4.2.1.4',
	'Param'		: '1.3.6.1.2.1.25.4.2.1.5'
}

lookup = [
	'closed',
	'listen',
	'synSent',
	'synReceived',
	'established',
	'finWait1',
	'finWait2',
	'closeWait',
	'lastAck',
	'closing',
	'timeWait',
	'deleteTCB'
]

status_table = [
	"up",
	"down",
	"testing",
	"unknown"
]

type_table = [
	"other",
	"regular1822",
	"hdh1822",
	"ddn-x25",
	"rfc877-x25",
	"ethernet-csmacd",
	"iso88023-csmacd",
	"iso88024-tokenBus",
	"iso88025-tokenRing",
	"iso88026-man",
	"starLan",
	"proteon-10Mbit",
	"proteon-80Mbit",
	"hyperchannel",
	"fddi",
	"lapb",
	"sdlc",
	"ds1",
	"e1",
	"basicISDN",
	"primaryISDN",
	"propPointToPointSerial",
	"ppp",
	"softwareLoopback",
	"eon",
	"ethernet-3Mbit",
	"nsip",
	"slip",
	"ultra",
	"ds3",
	"sip",
	"frame-relay",
	"unknown"
]

class BColors:  # easier to distinguish output
	def __init__(self):
		pass

	ok_green = '\033[92m'
	end_c = '\033[0m'


def snmpget(snmp_host, snmp_port, snmp_community, oid):
	cmd_gen = cmdgen.CommandGenerator()

	error_indication, error_status, error_index, var_binds = cmd_gen.getCmd(
		cmdgen.CommunityData(snmp_community),
		cmdgen.UdpTransportTarget((snmp_host, snmp_port)),
		oid)

	if error_indication:									# check for engine errors
		print(error_indication)

	else:
		if error_status:								# check for agent errors
			print('%s at %s' % (
				error_status.prettyPrint(),
				error_index and var_binds[int(error_index) - 1] or '?')
				  )

		else:
			for name, val in var_binds:						# snmp response contents
				# check for IP forwarding
				if key == 'IP forwarding enabled\t':
					if val.prettyPrint() != 1:
						print('%s: %s' % (key, "no"))

					else:
						print('%s: %s' % (key, "yes"))
				else:
					print('%s: %s' % (key, val.prettyPrint()))


def snmpwalk(snmp_host, snmp_port, snmp_community, oid):
	global name_list,path_list,port_list,addr_list
	global ladd, lprt,radd, rprt, cond, status, id_list
	global param_list,ifindex, ifdescr, ifmac, iftype
	global ifmtu, ifspeed, ifinoc, ifoutoc, ifstatus
	global ifidv, ipaddrv, netmaskv, bcastv, destv
	global hopv, maskv, metricv


	cmd_gen = cmdgen.CommandGenerator()

	error_indication, error_status, error_index, var_bind_table = cmd_gen.nextCmd(
		cmdgen.CommunityData(snmp_community),
		cmdgen.UdpTransportTarget((snmp_host, snmp_port)),
		oid
	)

	if error_status:
		print('%s at %s' % (
			error_status.prettyPrint(),
			error_index and var_bind_table[-1][int(error_index) - 1] or '?')
			  )
	else:
		for varBindTableRow in var_bind_table:
			for name, val in varBindTableRow:
				# for process information
				if key == 'Name':
					name_list += val.prettyPrint().split("\n")

				elif key == 'Path':
					path_list += val.prettyPrint().split("\n")

				elif key == 'id':
					id_list += val.prettyPrint().split("\n")

				elif key == 'status':
					if val.prettyPrint() == str(1):
						status += 'running',

					elif val.prettyPrint() == str(2):
						status += 'runnable',

					else:
						status += 'unknown',

				elif key == 'Param':
					param_list += val.prettyPrint().split("\n")
				# for routing information
				elif key == "dest":
					destv += val.prettyPrint().split("\n")
				elif key == "hop":
					hopv += val.prettyPrint().split("\n")
				elif key == "mask":
					maskv += val.prettyPrint().split("\n")
				elif key == "metric":
					metricv += val.prettyPrint().split("\n")
				# for network ip information
				elif key == "ifid":
					ifidv += val.prettyPrint().split("\n")
				elif key == "ipaddr":
					ipaddrv += val.prettyPrint().split("\n")
				elif key == "netmask":
					netmaskv += val.prettyPrint().split("\n")
				elif key == "bcast":
					bcastv += val.prettyPrint().split("\n")
				# for network interfaces
				elif key == 'index':
					ifindex += val.prettyPrint().split("\n")
				elif key == 'descr':
					ifdescr += val.prettyPrint().split("\n")
				elif key == 'mac':
					ifmac += val.prettyPrint().split("\n")
				elif key == 'type':
					iftype += val.prettyPrint().split("\n")
				elif key == 'mtu':
					ifmtu += val.prettyPrint().split("\n")
				elif key == 'speed':
					ifspeed += val.prettyPrint().split("\n")
				elif key == 'inoc':
					ifinoc += val.prettyPrint().split("\n")
				elif key == 'outoc':
					ifoutoc += val.prettyPrint().split("\n")
				elif key == 'cur_status':
					ifstatus += val.prettyPrint().split("\n")
				# for udp detection
				elif key == 'uaddress':
					addr_list += val.prettyPrint().split("\n")

				elif key == 'uport':
					port_list += val.prettyPrint().split("\n")
				# for tcp detection
				elif key == 'taddress':
					ladd += val.prettyPrint().split("\n")

				elif key == 'tport':
					lprt += val.prettyPrint().split("\n")

				elif key == 'raddress':
					radd += val.prettyPrint().split("\n")

				elif key == 'rport':
					rprt += val.prettyPrint().split("\n")

				elif key == 'state':
					cond += val.prettyPrint()

				else:
					print('%s: %s' % (key, val.prettyPrint()))


def snmpcheck(snmp_host, snmp_port, snmp_community):

	global key

	# enumerate system information
	print BColors.ok_green + "[*] System information:\n" + BColors.end_c
	print "Host IP\t\t\t: %s" % snmp_host
	for key in system_information:
		snmpget(snmp_host, snmp_port, snmp_community, system_information[key])

	# enumerate networking information
	print BColors.ok_green + "\n[*] Network information:\n" + BColors.end_c
	for key in network_information:
		snmpget(snmp_host, snmp_port, snmp_community, network_information[key])

	# enumerate networking interfaces
	print BColors.ok_green + "\n[*] Network interfaces:\n" + BColors.end_c
	for key in network_interfaces:
		snmpwalk(snmp_host, snmp_port, snmp_community, network_interfaces[key])

	i = len(ifindex)-1	# number of interfaces

	while i != -1:
		print (
			"Interface\t\t: "	+ "[%s] " % status_table[int(ifstatus[i])-1] + ifdescr[i]	+ "\n" +
			"Id\t\t\t: "		+ ifindex[i]							+ "\n" +
			"Mac Address\t\t: "	+ ":".join(				# very hackish I know don't
							[ifmac[i].split('0x')[1][n:n+2]	# look. This code snippet is
							for n in xrange(0, len(ifmac[i]	# ugly and it's proud!
							), 2)])[0:17]						+ "\n" +
			"Type\t\t\t: "		+ type_table[int(iftype[i])-1]					+ "\n" +
			"Speed\t\t\t: "		+ str((int(ifspeed[i]) / 1000000)) + " Mbps"			+ "\n" +
			"MTU\t\t\t: "		+ ifmtu[i]							+ "\n" +
			"In octets\t\t: "	+ ifinoc[i]							+ "\n" +
			"Out octets\t\t: "	+ ifoutoc[i]							+ "\n"
		)
		i -= 1

	# enumerate network ip
	print BColors.ok_green + "\n[*] Network IP:\n" + BColors.end_c
	for key in network_ip:
		snmpwalk(snmp_host, snmp_port, snmp_community, network_ip[key])

	print(
               "Id"		+ "\t" +
               "IP Address"	+ "\t" +
               "Netmask"	+ "\t" +
               "Broadcast"
	).expandtabs(30)

	for i in range(len(ifidv)):
		print(
			ifidv[i]	+ "\t" +
			ipaddrv[i]	+ "\t" +
			netmaskv[i]	+ "\t" +
			bcastv[i]
		).expandtabs(30)

	# enumerate routing information
	print BColors.ok_green + "\n[*] Routing information:\n" + BColors.end_c
	for key in routing_information:
		snmpwalk(snmp_host, snmp_port, snmp_community, routing_information[key])

	print(
               "Destination"	+ "\t" +
               "Next hop"	+ "\t" +
               "Mask"		+ "\t" +
               "Metric"
	).expandtabs(30)

	for i in range(len(destv)):
		print(
			destv[i]	+ "\t" +
			hopv[i]		+ "\t" +
			maskv[i]	+ "\t" +
			metricv[i]
		).expandtabs(30)



	# enumerate udp information
	print BColors.ok_green + "\n[*] Listening UDP ports:\n" + BColors.end_c
	for key in udp_port:
		snmpwalk(snmp_host, snmp_port, snmp_community, udp_port[key])

	for i in range(len(addr_list)):
		print(addr_list[i] + '\t' + port_list[i]).expandtabs(30)

	# enumerate tcp information
	print BColors.ok_green + "\n[*] Listening TCP ports:\n" + BColors.end_c
	for key in tcp_port:
		snmpwalk(snmp_host, snmp_port, snmp_community, tcp_port[key])

	print(
		"Local address"		+ '\t' +
		"Local port"		+ '\t' +
		"Remote address"	+ '\t' +
		"Remote port"		+ '\t' +
		'State'
	).expandtabs(30)

	for i in range(len(lprt)):
		print(
			ladd[i]	+ '\t' +
			lprt[i] + '\t' +
			radd[i] + '\t' +
			rprt[i] + '\t' +
			lookup[int(cond[i]) - 1]
		).expandtabs(30)

	# enumerate running processes
	print BColors.ok_green + "\n[*] Running Processes:\n" + BColors.end_c
	for key in processes:
		snmpwalk(snmp_host, snmp_port, snmp_community, processes[key])

	print(
		"Id"		+ "\t" +
		"Status"	+ "\t" +
		"Name"		+ "\t" +
		"Path"		+ "\t" +
		"Parameters"
	).expandtabs(30)

	for i in range(len(path_list)):
		print(
			id_list[i] + "\t" +
			status[i] + "\t" +
			name_list[i] + "\t" +
			path_list[i] + "\t" +
			param_list[i]
		).expandtabs(30)

	# enumerate usernames
	print BColors.ok_green + "\n[*] Usernames:\n" + BColors.end_c  # username enumeration
	for key in usernames:
		snmpwalk(snmp_host, snmp_port, snmp_community, usernames[key])


def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-t", "--target", help="target to enumerate")
	parser.add_argument("-p", "--port", help="target port")
	parser.add_argument("-c", "--community", help="public community string")
	args = parser.parse_args()
	snmp_host = args.target
	snmp_port = args.port
	snmp_community = args.community

	if snmp_host > 1:
		snmpcheck(snmp_host, int(snmp_port), snmp_community)

	else:
		print(parser.print_help())


if __name__ == '__main__':
	main()
