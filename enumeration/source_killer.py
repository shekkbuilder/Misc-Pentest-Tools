#!/usr/bin/env python
#
# Script name     : source_killer.py
# Version         : 2.0
# Created date    : 3/1/2017
# Last update     : 5/1/2017
# Author          : wetw0rk
# Python version  : 2.7
# Description     : Give it a local directory to walk and then files and directorys
#                   will be tested on the remote server. This at times can be more
#                   accurate then running say dirb? However this is not a bruteforcer this
#                   is mean't to be used on a web application you know the target host is
#                   running for example a cups install.
#

import os, sys, Queue, urllib2, threading
from termcolor import colored

try:
	target		= sys.argv[1]
	directory	= sys.argv[2]
	threads         = int(sys.argv[3])
except:
	print "Usage: %s <target> <open_source_app> <threads>" % sys.argv[0]
	print "Example: %s http://10.11.1.116 /root/Downloads/cups 1" % sys.argv[0]
	sys.exit()

# go to source directory
os.chdir(directory)
# create queue object
web_paths = Queue.Queue()

# walk source directory files
for r,d,f in os.walk("."):
	for files in f:
		# create path from files
		remote_path = "%s/%s" % (r,files)
		if remote_path.startswith("."):
			remote_path = remote_path[1:]
			# put path in queue
			web_paths.put(remote_path)

def test_remote():
	while not web_paths.empty():
		# get path from queue
		path = web_paths.get()
		# create url from path and target host
		url = "%s%s" % (target, path)
		print(colored("[try] => %s", "blue")) % url
		request = urllib2.Request(url)
		try:
			# attempt connetion
			response = urllib2.urlopen(request)
			content	= response.read()
			# if attempt response 200 print it
			print(colored("[%d] => %s", "blue", attrs=['bold'])) % (response.code,path)
			response.close()
		except:
			pass

# run x number of threads
for i in range(threads):
	# python counter starts at 0 not 1
	print(colored("[_+_] Spawning Thread: %d", "blue")) % (i + 1)
	# start thread
	t = threading.Thread(target=test_remote)
	t.start()


