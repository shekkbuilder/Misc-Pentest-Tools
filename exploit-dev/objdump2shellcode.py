#!/usr/bin/env python
#
# Script name     : objdump2shellcode.py
# Version         : 3.0
# Created date    : 5/27/2017
# Last update     : 7/27/2017
# Author          : wetw0rk
# Python version  : 2.7
# Description     : This is 1000000000 times easier than manually
#                   copying/pasting custom shellcode generated by
#                   objdump. python, perl, c, raw, and nasm types
#		    of output are currently supported.
#

import os, sys, subprocess, argparse

# one liner for evenly splitting the string was found here (not needed but nice):
# https://stackoverflow.com/questions/12328108/how-can-i-split-a-string-in-python
def print_shellcode(ops, mode, badchars):

	com = '"'
	bad = ""

	try:
		stop_now = badchars.split(",")
		for i in range(len(stop_now)):
			if stop_now[i] in ops:
				bad += "%s" % stop_now[i]

		if len(bad) > 1:
			print "Bad characters spotted: %s" % (bad)
		else:
			pass
	except:
		pass

	if mode == "python":
		print "Payload size: %d bytes" % (len(ops)/4)
		print 'buf = ""'
		splits = [ops[x:x+60] for x in range(0,len(ops),60)]
		for i in range(len(splits)):
			print "buf += \"" + splits[i] + com
	if mode == "c":
		print "Payload size: %d bytes" % (len(ops)/4)
		print "char shellcode[]= "
		splits = [ops[x:x+60] for x in range(0,len(ops),60)]
		for i in range(len(splits)):
			if i == (len(splits) -1):
				print com + splits[i] + com + ";"
			else:
				print com + splits[i] + com

	if mode == "perl":
		print "Payload size: %d bytes" % (len(ops)/4)
		print "my $buf ="
		splits = [ops[x:x+60] for x in range(0,len(ops),60)]
		for i in range(len(splits)):
			if i == (len(splits) -1):
				print com + splits[i] + com + ";"
			else:
				print com + splits[i] + com + " ."

	if mode == "nasm":
		print "Payload size: %d bytes" % (len(ops)/4)
		nasm = ""
		asm_ops = ops.split("\\x")
		for i in range(len(asm_ops)):
			if asm_ops[i] == '':
				pass
			else:
				nasm += "0x%s," % (asm_ops[i])
		split = [nasm[x:x+40] for x in range(0,len(nasm),40)]
		for i in range(len(split)):
			print "db " + split[i]

	if mode == "raw":
		print "Payload size: %d bytes" % (len(ops)/4)
		splits = [ops[x:x+60] for x in range(0,len(ops),60)]
		for i in range(len(splits)):
			print com + splits[i] + com

def dump_raw(dumpfile, mode, badchars):

	# detection for what we don't want. If you encounter any bug try adding
	# an extra character or string for our loop to detect it and get rid of
	# it.
	dirty = ["%", "$", "in", "jm", "no"]
	# list object to capture raw shellcode
	buf = []
	num = []
	ops = ""

	# detect if the file exists
	if os.path.isfile(dumpfile) is False:
		print "File non-existent!"
		sys.exit()

	# run objdump to extract raw shellcode
	try:
		dump_out = subprocess.Popen(['objdump', '-D', dumpfile],
			stdout=subprocess.PIPE).communicate()[0]
	except:
		print "[-] error running command"
		sys.exit()

	# split up the output by [tab]
	split = dump_out.split("\t")
	# loop through each string
	for i in range(len(split)):
		# get only our shellcode!
		if len(split[i]) == 21 or len(split[i]) == 13:
			if len(split[i]) == 21:
				buf += split[i],
			else:
				buf += split[i][:2],

	# loop for junk detection
	for i in range(len(buf)):
		for l in range(len(dirty)):
			if dirty[l] not in buf[i]:
				pass
			else:
				num += i,

	# cut off the junk!!!
	for i in range(len(buf)):
		if i not in num:
			each = buf[i].split(" ")
			for i in range(len(each)):
				if len(each[i]) > 0:
					ops += "\\x%s" % each[i]

	print_shellcode(ops, mode, badchars)

def main():

	# handle command line arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--dump", help="binary to dump shellcode from")
	parser.add_argument("-f", "--format", help="format of dump c, python, raw, perl, nasm")
	parser.add_argument("-b", "--badchar", help="seperate bad chars like so \\x00,\\x0a")
	args = parser.parse_args()
	# assign arguments
	dumpfile = args.dump
	mode = args.format
	badchars = args.badchar
	# pass to function
	if dumpfile > 1:
		dump_raw(dumpfile, mode, badchars)
	else:
		print(parser.print_help())

main()

