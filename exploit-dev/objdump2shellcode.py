#!/usr/bin/env python
#
# Script name     : objdump2shellcode.py
# Version         : 2.0
# Created date    : 5/27/2017
# Last update     : 7/22/2017
# Author          : wetw0rk
# Python version  : 2.7
# Description     : This is 1000000000 times easier that manually
#                   copying/pasting custom shellcode generated by
#                   objdump. python, perl, and c formatted output
#		    supported

import os, sys, subprocess, argparse

# one liner for evenly splitting the string was found here (not needed but nice):
# https://stackoverflow.com/questions/12328108/how-can-i-split-a-string-in-python
def print_shellcode(ops, mode, badchars):

	com = '"'
	bad = ""

	try:
		stop_now = badchars.split(",")
		for i in range(len(stop_now)):
			if stop_now[i] in ops:
				bad += "%s" % stop_now[i]

		if len(bad) > 1:
			print "Bad characters spotted: %s" % (bad)
		else:
			pass
	except:
		pass

	if mode == "python":
		print "Payload size: %d bytes" % (len(ops)/4)
		print 'buf = ""'
		splits = [ops[x:x+80] for x in range(0,len(ops),80)]
		for i in range(len(splits)):
			print "buf += \"" + splits[i] + com
	if mode == "c":
		print "Payload size: %d bytes" % (len(ops)/4)
		print "char shellcode[]= "
		splits = [ops[x:x+64] for x in range(0,len(ops),64)]
		for i in range(len(splits)):
			if i == (len(splits) -1):
				print com + splits[i] + com + ";"
			else:
				print com + splits[i] + com

	if mode == "perl":
		print "Payload size: %d bytes" % (len(ops)/4)
		print "my $buf ="
		splits = [ops[x:x+80] for x in range(0,len(ops),80)]
		for i in range(len(splits)):
			if i == (len(splits) -1):
				print com + splits[i] + com + ";"
			else:
				print com + splits[i] + com + " ."

	if mode == "raw":
		print "Payload size: %d bytes" % (len(ops)/4)
		splits = [ops[x:x+80] for x in range(0,len(ops),80)]
		for i in range(len(splits)):
			print com + splits[i] + com

def dump_raw(dumpfile, mode, badchars):

	# list object to capture raw shellcode
	buf = []
	ops = ""

	# detect if the file exists
	if os.path.isfile(dumpfile) is False:
		print "File non-existent!"
		sys.exit()

	# run objdump to extract raw shellcode
	try:
		dump_out = subprocess.Popen(['objdump', '-D', dumpfile],
			stdout=subprocess.PIPE).communicate()[0]
	except:
		print "[-] error running command"
		sys.exit()

	# split up the output by [tab]
	split = dump_out.split("\t")
	# loop through each string
	for i in range(len(split)):
		# get only our shellcode!
		if len(split[i]) == 21 or len(split[i]) == 13:
			if len(split[i]) == 21:
				buf += split[i],
			else:
				buf += split[i][:2],

	# neatly get that output
	for i in range(len(buf)):
		if "%" not in buf[i] and "in" not in buf[i] and "$" not in buf[i]:
			each = buf[i].split(" ")
			for i in range(len(each)):
				 if len(each[i]) > 0:
					ops += "\\x%s" % each[i]

	print_shellcode(ops, mode, badchars)

def main():

	# handle command line arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--dump", help="binary to dump shellcode from")
	parser.add_argument("-f", "--format", help="format of dump c, python, raw, perl")
	parser.add_argument("-b", "--badchar", help="seperate bad chars like so \\x00,\\x0a")
	args = parser.parse_args()
	# assign arguments
	dumpfile = args.dump
	mode = args.format
	badchars = args.badchar
	# pass to function
	if dumpfile > 1:
		dump_raw(dumpfile, mode, badchars)
	else:
		print(parser.print_help())

main()
